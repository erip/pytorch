#include <ATen/native/vulkan/glsl.h>
namespace at { namespace native { namespace vulkan { namespace gl {
const char* KO4C4HW_to_tex_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(binding=2) readonly buffer kernel{\n"
"    vec4 data[];\n"
"} uKernel;\n"
"layout(location = 3) uniform int uFxFy;\n"
"layout(location = 4) uniform int uIc_4;\n"
"layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID) * ivec3(4, 1, 1);\n"
"    int kernelPos = 0\n"
"    + pos.x * uFxFy\n"
"    + 4*pos.y * uIc_4 * uFxFy\n"
"    + 4*pos.z\n"
"    ;\n"
"    vec4 color0 = uKernel.data[kernelPos+0];\n"
"    vec4 color1 = uKernel.data[kernelPos+1];\n"
"    vec4 color2 = uKernel.data[kernelPos+2];\n"
"    vec4 color3 = uKernel.data[kernelPos+3];\n"
"    \n"
"    imageStore(uOutput, ivec3(pos.x+0, pos.y, pos.z), color0);\n"
"    imageStore(uOutput, ivec3(pos.x+1, pos.y, pos.z), color1);\n"
"    imageStore(uOutput, ivec3(pos.x+2, pos.y, pos.z), color2);\n"
"    imageStore(uOutput, ivec3(pos.x+3, pos.y, pos.z), color3);\n"
"}\n"
;
const char* addmm_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform PRECISION sampler3D uM1;\n"
"layout(location=2) uniform PRECISION sampler3D uM2;\n"
"layout(location=3) uniform PRECISION sampler3D uT;\n"
"layout(location=4) uniform float uBeta;\n"
"layout(location=5) uniform float uAlpha;\n"
"layout(location=6) uniform ivec3 uOutputSize;\n"
"layout(location=7) uniform int uK;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (all(lessThan(pos, uOutputSize)))\n"
"    {\n"
"      int K = uK;\n"
"      vec4 mmv = vec4(0);\n"
"      int ki = 0;\n"
"      for (; ki<K; ++ki)\n"
"      {\n"
"        vec4 m1ki = texelFetch(uM1, ivec3(ki, pos.y, pos.z), 0);\n"
"        vec4 m2ki = texelFetch(uM2, ivec3(pos.x, ki, pos.z), 0);\n"
"        mmv += m1ki * m2ki;\n"
"      }\n"
"      vec4 tv = texelFetch(uT, pos, 0);\n"
"      imageStore(uOutput, pos, uBeta * tv + uAlpha * mmv);\n"
"    }\n"
"}\n"
;
const char* binary_add_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform PRECISION sampler3D uInput0;\n"
"layout(location=2) uniform PRECISION sampler3D uInput1;\n"
"layout(location=3) uniform ivec4 imgSize;\n"
"layout(location=4) uniform float uAlpha;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    ivec3 inSize = imgSize.xyz;\n"
"    if(all(lessThan(pos, inSize)))\n"
"    {\n"
"        vec4 sum = texelFetch(uInput0, pos, 0) + uAlpha * texelFetch(uInput1, pos, 0);\n"
"        imageStore(uOutput, pos, sum);\n"
"    }\n"
"}\n"
;
const char* convDW_buf_IKnchw_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  float data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  float data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"  ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"  if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"  {\n"
"    int KW = uKernelSize.x;\n"
"    int KH = uKernelSize.y;\n"
"    ivec3 inputSize = uInputSize;\n"
"    int W = uInputSize.x;\n"
"    int H = uInputSize.y;\n"
"    int C = uInputSize.z;\n"
"    int OW = uOutputSize.x;\n"
"    int OH = uOutputSize.y;\n"
"    int GOC = uOutputSize.z;\n"
"    ivec2 s0 = pos.xy*uStride-uPad;\n"
"    int sx;\n"
"    int kxi, kyi;\n"
"    int goc = pos.z;\n"
"    int oci = goc / C;\n"
"    int ici = goc % C;\n"
"    ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"    ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"    float acc = uBias.data[oci];\n"
"    for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"    {\n"
"      int sy = kyi*uDilate.y + s0.y;\n"
"      for (kxi=0; kxi < KW; ++kxi)\n"
"      {\n"
"        sx = kxi*uDilate.x + s0.x;\n"
"        acc += uKernelBuffer.data[goc*KH*KW + kyi*KW + kxi] * uInBuffer.data[ici*H*W + sy*W + sx];\n"
"      }\n"
"    }\n"
"    uOutputBuffer.data[pos.x + OW*pos.y + goc*OW*OH] = acc;\n"
"  }\n"
"}\n"
;
const char* convDW_buf_IKnhwc_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutBuffer;\n"
"layout(binding=1) readonly buffer inBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  float data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C = uInputSize.y;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi;\n"
"        int c_4 = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 vk, vin;\n"
"        vec4 vacc = uBias.data[pos.z];\n"
"        int kBi, inBi;\n"
"        int c_4_ie = min(4, C - 4*c_4);\n"
"        int c_4_i;\n"
"        int sx, sy;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx = kxi*uDilate.x + s0.x;\n"
"                vk = vec4(0.0);\n"
"                vin = vec4(0.0);\n"
"                for(c_4_i=0; c_4_i<c_4_ie; ++c_4_i)\n"
"                {\n"
"                  inBi = (4 * c_4 + c_4_i) + (sy*W + sx) * C;\n"
"                  vin[c_4_i] = uInBuffer.data[inBi];\n"
"                  kBi = (kyi*KW + kxi) * C + (4 * c_4 + c_4_i);\n"
"                  vk[c_4_i] = uKernelBuffer.data[kBi];\n"
"                }\n"
"                vacc += vk * vin;\n"
"            }\n"
"        }\n"
"        int outBi = C*(OW*pos.y + pos.x) + 4*c_4;\n"
"        for(c_4_i=0; c_4_i<c_4_ie; ++c_4_i)\n"
"        {\n"
"            uOutBuffer.data[outBi + c_4_i] = vacc[c_4_i];\n"
"        }\n"
"    }\n"
"}\n"
;
const char* convDW_buf_Inhwc_Knchw_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  float data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C = uInputSize.y;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int C_4 = uOutputSize.z;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi;\n"
"        int c_4 = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 vacc = uBias.data[pos.z];\n"
"        vec4 vin, vk;\n"
"        int c_4_ie = min(4, C - 4*c_4);\n"
"        int c_4_i;\n"
"        int inBi, kBi;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx = kxi*uDilate.x + s0.x;\n"
"                vk = {0.0, 0.0, 0.0, 0.0};\n"
"                for(c_4_i=0; c_4_i<c_4_ie; ++c_4_i)\n"
"                {\n"
"                  inBi = (oc_4+c_4_i) + (sy*W + sx) * C;\n"
"                  kBi = (oc_4+c_4_i)*KH*KW + kyi*KW + kxi;\n"
"                  vk[c_4_i] = uKernelBuffer[kBi] * uInputBuffer[inBi];\n"
"                }\n"
"                vacc += vk * vin;\n"
"            }\n"
"        }\n"
"        int outBi = OC*(OW*pos.y + pos.x) + 4*pos.z;\n"
"        for(c_4_i=0; c_4_i<c_4_ie; ++c_4_i)\n"
"        {\n"
"            uOutputBuffer.data[outBi + c_4_i] = vacc[c_4_i];\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnchw_KrO4C4HW_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec4 uOutputSize;\n"
"layout(location=9) uniform ivec4 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize.xyz)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize.xyz;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int C = uInputSize.w;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        int OC = uOutputSize.w;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        ivec4 inBi, inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 v[4];\n"
"        vec4 invsx[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                int sx0 = kxi*uDilate.x + s0.x;\n"
"                int sx1 = sx0 + uStride.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    int kBi = oc_4i * (C_4 * KH * KW * 4) + ic_4i * KH * KW * 4 + (kxi + kyi*KW) * 4;\n"
"                    vec4 k0 = uKernelBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKernelBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKernelBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKernelBuffer.data[kBi+3];\n"
"                    for (int i = 0; i < 4; ++i) {\n"
"                      invsx[i] = vec4(0.0);\n"
"                    }\n"
"                    int ic4ie = min(4, C - 4*ic_4i);\n"
"                    for (int ic4i=0;ic4i<ic4ie; ++ic4i)\n"
"                    {\n"
"                      int inBi = (4*ic_4i + ic4i)*H*W + sy*W;\n"
"                      invsx[0][ic4i] = uInBuffer.data[inBi + sx0];\n"
"                      invsx[1][ic4i] = uInBuffer.data[inBi + sx1];\n"
"                      invsx[2][ic4i] = uInBuffer.data[inBi + sx2];\n"
"                      invsx[3][ic4i] = uInBuffer.data[inBi + sx3];\n"
"                    }\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    v[0] += k * invsx[0] * m0;\n"
"                    v[1] += k * invsx[1] * m1;\n"
"                    v[2] += k * invsx[2] * m2;\n"
"                    v[3] += k * invsx[3] * m3;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vi=0;\n"
"        int vie=min(4, OW-pos.x);\n"
"        int OWH = OW*OH;\n"
"        int outBi;\n"
"        for (;vi<vie;++vi)\n"
"        {\n"
"          outBi = (pos.x+vi) + OW*pos.y + 4*pos.z*OWH;\n"
"          vec4 v = v[vi];\n"
"          uOutBuffer.data[outBi+0] = v.x;\n"
"          uOutBuffer.data[outBi+1*OWH] = v.y;\n"
"          uOutBuffer.data[outBi+2*OWH] = v.z;\n"
"          uOutBuffer.data[outBi+3*OWH] = v.w;\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnchw_KrO4HWC_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec4 uOutputSize;\n"
"layout(location=9) uniform ivec4 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize.xyz)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize.xyz;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int C = uInputSize.w;\n"
"        int CAU4 = C_4 * 4;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        int OC = uOutputSize.w;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        ivec4 inBi, inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 v[4];\n"
"        vec4 invsx[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                int sx0 = kxi*uDilate.x + s0.x;\n"
"                int sx1 = sx0 + uStride.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                int kBi = kBi_oc4i_kyi + CAU4 * kxi;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    vec4 k0 = uKernelBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKernelBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKernelBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKernelBuffer.data[kBi+3];\n"
"                    for (int i = 0; i < 4; ++i) {\n"
"                      invsx[i] = vec4(0.0);\n"
"                    }\n"
"                    int ic4ie = min(4, C - 4*ic_4i);\n"
"                    for (int ic4i=0;ic4i<ic4ie; ++ic4i)\n"
"                    {\n"
"                      int inBi = (4*ic_4i + ic4i)*H*W + sy*W;\n"
"                      invsx[0][ic4i] = uInBuffer.data[inBi + sx0];\n"
"                      invsx[1][ic4i] = uInBuffer.data[inBi + sx1];\n"
"                      invsx[2][ic4i] = uInBuffer.data[inBi + sx2];\n"
"                      invsx[3][ic4i] = uInBuffer.data[inBi + sx3];\n"
"                    }\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    v[0] += k * invsx[0] * m0;\n"
"                    v[1] += k * invsx[1] * m1;\n"
"                    v[2] += k * invsx[2] * m2;\n"
"                    v[3] += k * invsx[3] * m3;\n"
"                    kBi += 4;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vi=0;\n"
"        int vie=min(4, OW-pos.x);\n"
"        int OWH = OW*OH;\n"
"        int outBi;\n"
"        for (;vi<vie;++vi)\n"
"        {\n"
"          outBi = (pos.x+vi) + OW*pos.y + 4*pos.z*OWH;\n"
"          vec4 v = v[vi];\n"
"          uOutputBuffer.data[outBi+0] = v.x;\n"
"          uOutputBuffer.data[outBi+1*OWH] = v.y;\n"
"          uOutputBuffer.data[outBi+2*OWH] = v.z;\n"
"          uOutputBuffer.data[outBi+3*OWH] = v.w;\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnchw_SIKOnc4hw_KrO4C4HW_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  vec4 data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  vec4 data[];\n"
"}uInputBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i, oc_4i;\n"
"        oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        int kBi_oc4i = oc_4i * (C_4 * KH * KW * 4);\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            int inBi_sy = sy * W;\n"
"            int kBi_oc4i_kyi = kBi_oc4i + kyi*KW*4;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                int kBi = kBi_oc4i_kyi + kxi*4;\n"
"                int sx0 = kxi*uDilate.x + s0.x;\n"
"                int sx1 = sx0 + uStride.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                int inBi = inBi_sy;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    vec4 k0 = uKernelBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKernelBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKernelBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKernelBuffer.data[kBi+3];\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    v[0] += k*uInputBuffer.data[inBi+sx0] * m0;\n"
"                    v[1] += k*uInputBuffer.data[inBi+sx1] * m1;\n"
"                    v[2] += k*uInputBuffer.data[inBi+sx2] * m2;\n"
"                    v[3] += k*uInputBuffer.data[inBi+sx3] * m3;\n"
"                    inBi += W * H;\n"
"                    kBi += KH * KW * 4;\n"
"                }\n"
"            }\n"
"        }\n"
"        int outBi = pos.z * OW * OH + pos.y * OW + pos.x;\n"
"        int vi=0;\n"
"        int vie=min(4, OW-pos.x);\n"
"        for (;vi<vie;++vi)\n"
"        {\n"
"          uOutputBuffer.data[outBi+vi] = v[vi];\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnchw_SIKOnc4hw_KrO4HWC_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  vec4 data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  vec4 data[];\n"
"}uInputBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int CAU4 = C_4 * 4;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i, oc_4i;\n"
"        oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        int kBi_oc4i = oc_4i * CAU4 * KH * KW;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            int inBi_sy = sy * W;\n"
"            int kBi_oc4i_kyi = kBi_oc4i + kyi*KW*CAU4;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                int sx0 = kxi*uDilate.x + s0.x;\n"
"                int sx1 = sx0 + uStride.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                int inBi = inBi_sy;\n"
"                int kBi = kBi_oc4i_kyi + CAU4 * kxi;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    vec4 k0 = uKernelBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKernelBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKernelBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKernelBuffer.data[kBi+3];\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    v[0] += k*uInputBuffer.data[inBi + sx0] * m0;\n"
"                    v[1] += k*uInputBuffer.data[inBi + sx1] * m1;\n"
"                    v[2] += k*uInputBuffer.data[inBi + sx2] * m2;\n"
"                    v[3] += k*uInputBuffer.data[inBi + sx3] * m3;\n"
"                    inBi += W*H;\n"
"                    kBi += 4;\n"
"                }\n"
"            }\n"
"        }\n"
"        int outBi = pos.z * OW * OH + pos.y * OW + pos.x;\n"
"        int vi=0;\n"
"        int vie=min(4, OW-pos.x);\n"
"        for (;vi<vie;++vi)\n"
"        {\n"
"          uOutputBuffer.data[outBi+vi] = v[vi];\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnchw_SIKnc4hw_SOnchw_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  vec4 data[];\n"
"}uInputBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                int sx0 = kxi*uDilate.x + s0.x;\n"
"                int sx1 = sx0 + uStride.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    int kBi = oc_4i * (C_4 * KH * KW * 4) + ic_4i * KH * KW * 4 + (kxi + kyi*KW) * 4;\n"
"                    vec4 k0 = uKernelBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKernelBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKernelBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKernelBuffer.data[kBi+3];\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    int inBi = ic_4i * W * H + sy * W;\n"
"                    int inBi0 = inBi + sx0;\n"
"                    int inBi1 = inBi + sx1;\n"
"                    int inBi2 = inBi + sx2;\n"
"                    int inBi3 = inBi + sx3;\n"
"                    v[0] += k*uInputBuffer.data[inBi0] * m0;\n"
"                    v[1] += k*uInputBuffer.data[inBi1] * m1;\n"
"                    v[2] += k*uInputBuffer.data[inBi2] * m2;\n"
"                    v[3] += k*uInputBuffer.data[inBi3] * m3;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vi=0;\n"
"        int vie=min(4, OW-pos.x);\n"
"        int OWH = OW*OH;\n"
"        int outBi;\n"
"        for (;vi<vie;++vi)\n"
"        {\n"
"          outBi = (pos.x+vi) + OW*pos.y + 4*pos.z*OWH;\n"
"          vec4 v = v[vi];\n"
"          uOutputBuffer.data[outBi+0] = v.x;\n"
"          uOutputBuffer.data[outBi+1*OWH] = v.y;\n"
"          uOutputBuffer.data[outBi+2*OWH] = v.z;\n"
"          uOutputBuffer.data[outBi+3*OWH] = v.w;\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnchw_SKnc4hw_KrO4C4HW_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        ivec4 inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 k0, k1, k2, k3;\n"
"        int kBi_oc4_i = oc_4i * (C_4 * KH * KW * 4);\n"
"        int kBi;\n"
"        int sx0, sx1, sx2, sx3;\n"
"        ivec4 inBi;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx0 = kxi*uDilate.x + s0.x;\n"
"                sx1 = sx0 + uStride.x;\n"
"                sx2 = sx1 + uStride.x;\n"
"                sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                kBi = kBi_oc4_i + (kxi + kyi*KW) * 4;\n"
"                inBi.x = sy*W;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    k0 = uKernelBuffer.data[kBi+0];\n"
"                    k1 = uKernelBuffer.data[kBi+1];\n"
"                    k2 = uKernelBuffer.data[kBi+2];\n"
"                    k3 = uKernelBuffer.data[kBi+3];\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    inBi.y = inBi.x + W*H;\n"
"                    inBi.z = inBi.y + W*H;\n"
"                    inBi.w = inBi.z + W*H;\n"
"                    inBisx0 = inBi + sx0;\n"
"                    inBisx1 = inBi + sx1;\n"
"                    inBisx2 = inBi + sx2;\n"
"                    inBisx3 = inBi + sx3;\n"
"                    vec4 invsx0 = vec4(uInBuffer.data[inBisx0.x],uInBuffer.data[inBisx0.y],uInBuffer.data[inBisx0.z],uInBuffer.data[inBisx0.w]);\n"
"                    vec4 invsx1 = vec4(uInBuffer.data[inBisx1.x],uInBuffer.data[inBisx1.y],uInBuffer.data[inBisx1.z],uInBuffer.data[inBisx1.w]);\n"
"                    vec4 invsx2 = vec4(uInBuffer.data[inBisx2.x],uInBuffer.data[inBisx2.y],uInBuffer.data[inBisx2.z],uInBuffer.data[inBisx2.w]);\n"
"                    vec4 invsx3 = vec4(uInBuffer.data[inBisx3.x],uInBuffer.data[inBisx3.y],uInBuffer.data[inBisx3.z],uInBuffer.data[inBisx3.w]);\n"
"                    v[0] += k * invsx0 * m0;\n"
"                    v[1] += k * invsx1 * m1;\n"
"                    v[2] += k * invsx2 * m2;\n"
"                    v[3] += k * invsx3 * m3;\n"
"                    kBi += KH * KW * 4;\n"
"                    inBi.x += W*H;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vi=0;\n"
"        int vie=min(4, OW-pos.x);\n"
"        int OWH = OW*OH;\n"
"        int outBi;\n"
"        for (;vi<vie;++vi)\n"
"        {\n"
"          outBi = (pos.x+vi) + OW*pos.y + 4*pos.z*OWH;\n"
"          vec4 v = v[vi];\n"
"          uOutputBuffer.data[outBi+0] = v.x;\n"
"          uOutputBuffer.data[outBi+1*OWH] = v.y;\n"
"          uOutputBuffer.data[outBi+2*OWH] = v.z;\n"
"          uOutputBuffer.data[outBi+3*OWH] = v.w;\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnhwc_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  float data[];\n"
"}uKBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec4 uOutputSize;\n"
"layout(location=9) uniform ivec4 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize.xyz)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int posx_4 = pos.x / 4;\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec4 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int C = uInputSize.w;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        int OC = uOutputSize.w;\n"
"        int OW_4 = UP_DIV(OW, 4);\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        ivec4 inBi, inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 k[4];\n"
"        vec4 invsx[4];\n"
"        int sx0, sx1, sx2, sx3;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx0 = kxi*uDilate.x + s0.x;\n"
"                sx1 = sx0 + uStride.x;\n"
"                sx2 = sx1 + uStride.x;\n"
"                sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    for (int i = 0; i < 4; ++i) {\n"
"                      k[i] = vec4(0.0);\n"
"                      invsx[i] = vec4(0.0);\n"
"                    }\n"
"                    int ic4ie = min(4, C - 4*ic_4i);\n"
"                    int kBi0 = C*KH*KW*(oc_4i+0) + C*(kyi*KW+kxi) + 4*ic_4i;\n"
"                    for (int ic4i=0;ic4i<ic4ie; ++ic4i)\n"
"                    {\n"
"                      k[ic4i][0] = uKBuffer.data[kBi0 + 0*C*KH*KW + ic4i];\n"
"                      k[ic4i][1] = uKBuffer.data[kBi0 + 1*C*KH*KW + ic4i];\n"
"                      k[ic4i][2] = uKBuffer.data[kBi0 + 2*C*KH*KW + ic4i];\n"
"                      k[ic4i][3] = uKBuffer.data[kBi0 + 3*C*KH*KW + ic4i];\n"
"                      invsx[0][ic4i] = uInBuffer.data[C*(W*sy + sx0) + 4*ic_4i + ic4i];\n"
"                      invsx[1][ic4i] = uInBuffer.data[C*(W*sy + sx1) + 4*ic_4i + ic4i];\n"
"                      invsx[2][ic4i] = uInBuffer.data[C*(W*sy + sx2) + 4*ic_4i + ic4i];\n"
"                      invsx[3][ic4i] = uInBuffer.data[C*(W*sy + sx3) + 4*ic_4i + ic4i];\n"
"                    }\n"
"                    mat4 kmat = mat4(k[0], k[1], k[2], k[3]);\n"
"                    v[0] += kmat * invsx[0] * m0;\n"
"                    v[1] += kmat * invsx[1] * m1;\n"
"                    v[2] += kmat * invsx[2] * m2;\n"
"                    v[3] += kmat * invsx[3] * m3;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vxi = 0;\n"
"        int vxie = min(4, OW-pos.x);\n"
"        int vci = 0;\n"
"        int vcie = min(4, OC-4*oc_4i);\n"
"        for (;vxi<vxie;++vxi)\n"
"        {\n"
"          int outBi = OC*(OW*pos.y + pos.x + vxi) + 4*oc_4i;\n"
"          vec4 v = v[vxi];\n"
"          vci = 0;\n"
"          for(;vci<vcie;++vci)\n"
"          {\n"
"            uOutputBuffer.data[outBi + vci] = v[vci];\n"
"          }\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnhwc_KrO4C4HW_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec4 uOutputSize;\n"
"layout(location=9) uniform ivec4 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize.xyz)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int posx_4 = pos.x / 4;\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec4 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int C = uInputSize.w;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        int OC = uOutputSize.w;\n"
"        int OW_4 = UP_DIV(OW, 4);\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        ivec4 inBi, inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 k[4];\n"
"        vec4 invsx[4];\n"
"        int sx0, sx1, sx2, sx3;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx0 = kxi*uDilate.x + s0.x;\n"
"                sx1 = sx0 + uStride.x;\n"
"                sx2 = sx1 + uStride.x;\n"
"                sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    int kBi = oc_4i * (C_4 * 4 * KH * KW) + ic_4i * 4 * KH * KW + (kxi + kyi*KW) * 4;\n"
"                    vec4 k0 = uKBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKBuffer.data[kBi+3];\n"
"                    for (int i = 0; i < 4; ++i) {\n"
"                      k[i] = vec4(0.0);\n"
"                      invsx[i] = vec4(0.0);\n"
"                    }\n"
"                    int ic4ie = min(4, C - 4*ic_4i);\n"
"                    for (int ic4i=0;ic4i<ic4ie; ++ic4i)\n"
"                    {\n"
"                      invsx[0][ic4i] = uInBuffer.data[C*(W*sy + sx0) + 4*ic_4i + ic4i];\n"
"                      invsx[1][ic4i] = uInBuffer.data[C*(W*sy + sx1) + 4*ic_4i + ic4i];\n"
"                      invsx[2][ic4i] = uInBuffer.data[C*(W*sy + sx2) + 4*ic_4i + ic4i];\n"
"                      invsx[3][ic4i] = uInBuffer.data[C*(W*sy + sx3) + 4*ic_4i + ic4i];\n"
"                    }\n"
"                    mat4 kmat = mat4(k0, k1, k2, k3);\n"
"                    v[0] += kmat * invsx[0] * m0;\n"
"                    v[1] += kmat * invsx[1] * m1;\n"
"                    v[2] += kmat * invsx[2] * m2;\n"
"                    v[3] += kmat * invsx[3] * m3;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vxi = 0;\n"
"        int vxie = min(4, OW-pos.x);\n"
"        int vci = 0;\n"
"        int vcie = min(4, OC-4*oc_4i);\n"
"        for (;vxi<vxie;++vxi)\n"
"        {\n"
"          int outBi = OC*(OW*pos.y + pos.x + vxi) + 4*oc_4i;\n"
"          vec4 v = v[vxi];\n"
"          vci = 0;\n"
"          for(;vci<vcie;++vci)\n"
"          {\n"
"            uOutputBuffer.data[outBi + vci] = v[vci];\n"
"          }\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_IKnhwc_KrO4HWC_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec4 uOutputSize;\n"
"layout(location=9) uniform ivec4 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize.xyz)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int posx_4 = pos.x / 4;\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec4 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C_4 = uInputSize.z;\n"
"        int C = uInputSize.w;\n"
"        int CAU4 = C_4 * 4;\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC_4 = uOutputSize.z;\n"
"        int OC = uOutputSize.w;\n"
"        int OW_4 = UP_DIV(OW, 4);\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        ivec4 inBi, inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 k[4];\n"
"        vec4 invsx[4];\n"
"        int sx0, sx1, sx2, sx3;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx0 = kxi*uDilate.x + s0.x;\n"
"                sx1 = sx0 + uStride.x;\n"
"                sx2 = sx1 + uStride.x;\n"
"                sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    int kBi = oc_4i * (CAU4 * KH * KW) + CAU4 *(kxi + kyi*KW) +  4 * ic_4i;\n"
"                    vec4 k0 = uKBuffer.data[kBi+0];\n"
"                    vec4 k1 = uKBuffer.data[kBi+1];\n"
"                    vec4 k2 = uKBuffer.data[kBi+2];\n"
"                    vec4 k3 = uKBuffer.data[kBi+3];\n"
"                    for (int i = 0; i < 4; ++i) {\n"
"                      k[i] = vec4(0.0);\n"
"                      invsx[i] = vec4(0.0);\n"
"                    }\n"
"                    int ic4ie = min(4, C - 4*ic_4i);\n"
"                    for (int ic4i=0;ic4i<ic4ie; ++ic4i)\n"
"                    {\n"
"                      invsx[0][ic4i] = uInBuffer.data[C*(W*sy + sx0) + 4*ic_4i + ic4i];\n"
"                      invsx[1][ic4i] = uInBuffer.data[C*(W*sy + sx1) + 4*ic_4i + ic4i];\n"
"                      invsx[2][ic4i] = uInBuffer.data[C*(W*sy + sx2) + 4*ic_4i + ic4i];\n"
"                      invsx[3][ic4i] = uInBuffer.data[C*(W*sy + sx3) + 4*ic_4i + ic4i];\n"
"                    }\n"
"                    mat4 kmat = mat4(k0, k1, k2, k3);\n"
"                    v[0] += kmat * invsx[0] * m0;\n"
"                    v[1] += kmat * invsx[1] * m1;\n"
"                    v[2] += kmat * invsx[2] * m2;\n"
"                    v[3] += kmat * invsx[3] * m3;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vxi = 0;\n"
"        int vxie = min(4, OW-pos.x);\n"
"        int vci = 0;\n"
"        int vcie = min(4, OC-4*oc_4i);\n"
"        for (;vxi<vxie;++vxi)\n"
"        {\n"
"          int outBi = OC*(OW*pos.y + pos.x + vxi) + 4*oc_4i;\n"
"          vec4 v = v[vxi];\n"
"          vci = 0;\n"
"          for(;vci<vcie;++vci)\n"
"          {\n"
"            uOutputBuffer.data[outBi + vci] = v[vci];\n"
"          }\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_buf_Inhwc_Knchw_KrO4C4HW_glsl = 
"layout(std430) buffer;\n"
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutputBuffer;\n"
"layout(binding=1) readonly buffer inputBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(binding=2) readonly buffer kernelBuffer{\n"
"  vec4 data[];\n"
"}uKernelBuffer;\n"
"layout(binding=3) readonly buffer bias{\n"
"  vec4 data[];\n"
"}uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform ivec3 uOutputSize;\n"
"layout(location=9) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(4, 1, 1);\n"
"        int KW = uKernelSize.x;\n"
"        int KH = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        int W = uInputSize.x;\n"
"        int H = uInputSize.y;\n"
"        int C = uInputSize.z;\n"
"        int C_4 = UP_DIV(C, 4);\n"
"        int OW = uOutputSize.x;\n"
"        int OH = uOutputSize.y;\n"
"        int OC = uOutputSize.z;\n"
"        int OC_4 = UP_DIV(OC, 4);\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int kxi, kyi, ic_4i;\n"
"        int oc_4i = pos.z;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 v[4];\n"
"        v[0] = uBias.data[pos.z];\n"
"        v[1] = v[0];\n"
"        v[2] = v[0];\n"
"        v[3] = v[0];\n"
"        ivec4 inBi, inBisx0, inBisx1, inBisx2, inBisx3;\n"
"        vec4 k0, k1, k2, k3;\n"
"        int kBi_oc4_i = oc_4i * (C_4 * KH * KW * 4);\n"
"        int kBi;\n"
"        int sx0, sx1, sx2, sx3;\n"
"        for (kyi=sfxy.y; kyi<efxy.y; ++kyi)\n"
"        {\n"
"            int sy = kyi*uDilate.y + s0.y;\n"
"            for (kxi=0; kxi < KW; ++kxi)\n"
"            {\n"
"                sx0 = kxi*uDilate.x + s0.x;\n"
"                sx1 = sx0 + uStride.x;\n"
"                sx2 = sx1 + uStride.x;\n"
"                sx3 = sx2 + uStride.x;\n"
"                float m0 = sx0 >= 0 && sx0 < W ? 1.0 : 0.0;\n"
"                float m1 = sx1 >= 0 && sx1 < W ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < W ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < W ? 1.0 : 0.0;\n"
"                kBi = kBi_oc4_i + (kxi + kyi*KW) * 4;\n"
"                for (ic_4i=0; ic_4i < C_4; ++ic_4i)\n"
"                {\n"
"                    k0 = uKernelBuffer.data[kBi+0];\n"
"                    k1 = uKernelBuffer.data[kBi+1];\n"
"                    k2 = uKernelBuffer.data[kBi+2];\n"
"                    k3 = uKernelBuffer.data[kBi+3];\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    inBi.x = W * C * sy + ic_4i + 0;\n"
"                    inBi.y = W * C * sy + ic_4i + 1;\n"
"                    inBi.z = W * C * sy + ic_4i + 2;\n"
"                    inBi.w = W * C * sy + ic_4i + 3;\n"
"                    inBisx0 = inBi + C * sx0;\n"
"                    inBisx1 = inBi + C * sx1;\n"
"                    inBisx2 = inBi + C * sx2;\n"
"                    inBisx3 = inBi + C * sx3;\n"
"                    vec4 invsx0 = vec4(uInBuffer.data[inBisx0.x],uInBuffer.data[inBisx0.y],uInBuffer.data[inBisx0.z],uInBuffer.data[inBisx0.w]);\n"
"                    vec4 invsx1 = vec4(uInBuffer.data[inBisx1.x],uInBuffer.data[inBisx1.y],uInBuffer.data[inBisx1.z],uInBuffer.data[inBisx1.w]);\n"
"                    vec4 invsx2 = vec4(uInBuffer.data[inBisx2.x],uInBuffer.data[inBisx2.y],uInBuffer.data[inBisx2.z],uInBuffer.data[inBisx2.w]);\n"
"                    vec4 invsx3 = vec4(uInBuffer.data[inBisx3.x],uInBuffer.data[inBisx3.y],uInBuffer.data[inBisx3.z],uInBuffer.data[inBisx3.w]);\n"
"                    v[0] += k * invsx0 * m0;\n"
"                    v[1] += k * invsx1 * m1;\n"
"                    v[2] += k * invsx2 * m2;\n"
"                    v[3] += k * invsx3 * m3;\n"
"                    kBi += KH * KW * 4;\n"
"                }\n"
"            }\n"
"        }\n"
"        int vxi = 0;\n"
"        int vxie = min(4, OW-pos.x);\n"
"        int vci = 0;\n"
"        int vcie = min(4, OC-4*pos.z);\n"
"        for (;vxi<vxie;++vxi)\n"
"        {\n"
"          int outBi = OW*OC*pos.y + OC*(pos.x + vxi) + 4*pos.z;\n"
"          vec4 v = v[vxi];\n"
"          vci = 0;\n"
"          for(;vci<vcie;++vci)\n"
"          {\n"
"            uOutputBuffer.data[outBi + vci] = v[vci];\n"
"          }\n"
"        }\n"
"    }\n"
"}\n"
;
const char* conv_tex_IKnc4hw_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform PRECISION sampler3D uInput;\n"
"layout(location=2) uniform PRECISION sampler3D uKernel;\n"
"layout(binding=3) readonly buffer bias{\n"
"    vec4 data[];\n"
"} uBias;\n"
"layout(location=4) uniform ivec2 uPad;\n"
"layout(location=5) uniform ivec2 uKernelSize;\n"
"layout(location=6) uniform ivec2 uStride;\n"
"layout(location=7) uniform ivec2 uDilate;\n"
"layout(location=8) uniform int uUnroll;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    if (all(lessThan(ivec3(gl_GlobalInvocationID), uOutputSize)))\n"
"    {\n"
"        ivec3 pos = ivec3(gl_GlobalInvocationID)*ivec3(uUnroll, 1, 1);\n"
"        int kernelX = uKernelSize.x;\n"
"        int kernelY = uKernelSize.y;\n"
"        ivec3 inputSize = uInputSize;\n"
"        ivec2 s0 = pos.xy*uStride-uPad;\n"
"        int fx, fy, fz;\n"
"        ivec2 sfxy = max(ivec2(0), (UP_DIV(-s0, uDilate)));\n"
"        ivec2 efxy = min(uKernelSize, UP_DIV(inputSize.xy-s0, uDilate));\n"
"        vec4 color = uBias.data[pos.z];\n"
"        vec4 color2 = color;\n"
"        vec4 color3 = color;\n"
"        vec4 color4 = color;\n"
"        int kY = pos.z;\n"
"        for (fy=sfxy.y; fy<efxy.y; ++fy)\n"
"        {\n"
"            int sy = fy*uDilate.y + s0.y;\n"
"            for (fx=0; fx<kernelX; ++fx)\n"
"            {\n"
"                int kZ = fx + fy*kernelX;\n"
"                int sx1 = fx*uDilate.x + s0.x;\n"
"                int sx2 = sx1 + uStride.x;\n"
"                int sx3 = sx1 + uStride.x * 2;\n"
"                int sx4 = sx1 + uStride.x * 3;\n"
"                float m1 = sx1 >= 0 && sx1 < inputSize.x ? 1.0 : 0.0;\n"
"                float m2 = sx2 >= 0 && sx2 < inputSize.x ? 1.0 : 0.0;\n"
"                float m3 = sx3 >= 0 && sx3 < inputSize.x ? 1.0 : 0.0;\n"
"                float m4 = sx4 >= 0 && sx4 < inputSize.x ? 1.0 : 0.0;\n"
"                fz = 0;\n"
"                for (; fz<inputSize.z; ++fz)\n"
"                {\n"
"                    int kX = 4*fz;\n"
"                    vec4 k0 = texelFetch(uKernel, ivec3(kX+0, kY, kZ), 0);\n"
"                    vec4 k1 = texelFetch(uKernel, ivec3(kX+1, kY, kZ), 0);\n"
"                    vec4 k2 = texelFetch(uKernel, ivec3(kX+2, kY, kZ), 0);\n"
"                    vec4 k3 = texelFetch(uKernel, ivec3(kX+3, kY, kZ), 0);\n"
"                    mat4 k = mat4(k0, k1, k2, k3);\n"
"                    color  += k*texelFetch(uInput, ivec3(sx1, sy, fz), 0) * m1;\n"
"                    color2 += k*texelFetch(uInput, ivec3(sx2, sy, fz), 0) * m2;\n"
"                    color3 += k*texelFetch(uInput, ivec3(sx3, sy, fz), 0) * m3;\n"
"                    color4 += k*texelFetch(uInput, ivec3(sx4, sy, fz), 0) * m4;\n"
"                }\n"
"            }\n"
"        }\n"
"        imageStore(uOutput, ivec3(pos.x+0, pos.y, pos.z), color);\n"
"        imageStore(uOutput, ivec3(pos.x+1, pos.y, pos.z), color2);\n"
"        imageStore(uOutput, ivec3(pos.x+2, pos.y, pos.z), color3);\n"
"        imageStore(uOutput, ivec3(pos.x+3, pos.y, pos.z), color4);\n"
"    }\n"
"}\n"
;
const char* gemm_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform PRECISION sampler3D uM1;\n"
"layout(location=2) uniform PRECISION sampler3D uM2;\n"
"layout(location=3) uniform ivec3 uOutputSize;\n"
"layout(location=4) uniform int uK;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (all(lessThan(pos, uOutputSize)))\n"
"    {\n"
"      int K = uK;\n"
"      vec4 ov = vec4(0);\n"
"      int ki = 0;\n"
"      for (; ki<K; ++ki)\n"
"      {\n"
"        vec4 m1ki = texelFetch(uM1, ivec3(ki, pos.y, pos.z), 0);\n"
"        vec4 m2ki = texelFetch(uM2, ivec3(pos.x, ki, pos.z), 0);\n"
"        ov += m1ki * m2ki;\n"
"      }\n"
"      imageStore(uOutput, ivec3(pos.x, pos.y, pos.z), ov);\n"
"    }\n"
"}\n"
;
const char* maxpool2d_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(FORMAT, binding=1) readonly uniform PRECISION image3D uInput;\n"
"layout(location = 2) uniform ivec2 uKernel;\n"
"layout(location = 3) uniform ivec2 uStride;\n"
"layout(location = 4) uniform ivec2 uPad;\n"
"layout(location = 5) uniform ivec2 uDilate;\n"
"layout(location=10) uniform ivec3 uOutputSize;\n"
"layout(location=11) uniform ivec3 uInputSize;\n"
"#define UP_DIV(x, y) (((x)+(y)-1)/(y))\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    ivec3 outputSize = uOutputSize;\n"
"    ivec2 spos = pos.xy*uStride-uPad;\n"
"    if (all(lessThan(pos, outputSize)))\n"
"    {\n"
"        ivec3 inputSize = uInputSize;\n"
"        ivec2 sfxy = max(ivec2(0), UP_DIV(-spos, uDilate));\n"
"        ivec2 efxy = min(uKernel, UP_DIV(inputSize.xy-spos, uDilate));\n"
"        vec4 v = vec4(-100000.0);\n"
"        for (int fy=sfxy.y; fy<efxy.y; ++fy)\n"
"        {\n"
"            for (int fx=sfxy.x; fx<efxy.x; ++fx)\n"
"            {\n"
"                v = max(v, imageLoad(uInput, ivec3(spos.x+fx, spos.y+fy, pos.z)));\n"
"            }\n"
"        }\n"
"        imageStore(uOutput, pos, v);\n"
"    }\n"
"}\n"
;
const char* nc4hw4_buf_to_tex_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) readonly buffer destBuffer{\n"
"    vec4 data[];\n"
"} uInBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color = uInBuffer.data[uWidth*pos.y+pos.x+pos.z*uWidth*uHeight];\n"
"        imageStore(uImage, pos, color);\n"
"    }\n"
"}\n"
;
const char* nc4hw_buf_to_nchw_buf_glsl = 
"layout(binding=0) writeonly buffer outBuffer{\n"
"  float data[];\n"
"}uOutBuffer;\n"
"layout(binding=1) readonly buffer inBuffer{\n"
"  vec4 data[];\n"
"}uInBuffer;\n"
"layout(location=2) uniform ivec2 uInputSize;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    int W = uInputSize.x;\n"
"    int H = uInputSize.y;\n"
"    if (pos.x < W && pos.y < H)\n"
"    {\n"
"      vec4 v = uInBuffer.data[pos.z * W * H + pos.y * W + pos.x];\n"
"      int z = pos.z*4;\n"
"      uOutBuffer.data[pos.x + W*pos.y + (z+0)*W*H] = v.x;\n"
"      uOutBuffer.data[pos.x + W*pos.y + (z+1)*W*H] = v.y;\n"
"      uOutBuffer.data[pos.x + W*pos.y + (z+2)*W*H] = v.z;\n"
"      uOutBuffer.data[pos.x + W*pos.y + (z+3)*W*H] = v.w;\n"
"    }\n"
"}\n"
;
const char* nchw_buf_to_nc4hw_buf_glsl = 
"layout(binding=0) writeonly buffer dstBuffer{\n"
"  float data[];\n"
"}uOutBuffer;\n"
"layout(binding=1) readonly buffer srcBuffer{\n"
"  float data[];\n"
"}uInBuffer;\n"
"layout(location=2) uniform int uWidth;\n"
"layout(location=3) uniform int uHeight;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"  ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"  int W = uWidth;\n"
"  int H = uHeight;\n"
"  int WH = W * H;\n"
"  if (pos.x < W && pos.y < H)\n"
"  {\n"
"      int z4 = pos.z*4;\n"
"      int y4 = pos.y*4;\n"
"      int x4 = pos.x*4;\n"
"      uOutBuffer.data[z4*WH + y4*W + x4 + 0] = uInBuffer.data[(z4+0)*WH + W*pos.y + pos.x];\n"
"      uOutBuffer.data[z4*WH + y4*W + x4 + 1] = uInBuffer.data[(z4+1)*WH + W*pos.y + pos.x];\n"
"      uOutBuffer.data[z4*WH + y4*W + x4 + 2] = uInBuffer.data[(z4+2)*WH + W*pos.y + pos.x];\n"
"      uOutBuffer.data[z4*WH + y4*W + x4 + 3] = uInBuffer.data[(z4+3)*WH + W*pos.y + pos.x];\n"
"  }\n"
"}\n"
;
const char* nchw_buf_to_tex_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) readonly buffer destBuffer{\n"
"    float data[];\n"
"} uInBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color;\n"
"        int z = pos.z*4;\n"
"        color.r = uInBuffer.data[uWidth*pos.y+pos.x+(z+0)*uWidth*uHeight];\n"
"        color.g = uInBuffer.data[uWidth*pos.y+pos.x+(z+1)*uWidth*uHeight];\n"
"        color.b = uInBuffer.data[uWidth*pos.y+pos.x+(z+2)*uWidth*uHeight];\n"
"        color.a = uInBuffer.data[uWidth*pos.y+pos.x+(z+3)*uWidth*uHeight];\n"
"        imageStore(uImage, pos, color);\n"
"    }\n"
"}\n"
;
const char* nhwc_buf_to_tex_glsl = 
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) readonly buffer destBuffer{\n"
"    float data[];\n"
"} uInBuffer;\n"
"layout(location = 2) uniform ivec4 uInputSize;\n"
"layout(location = 3) uniform int uH;\n"
"layout(location = 4) uniform int uC;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    int W = uInputSize.x;\n"
"    int H = uInputSize.y;\n"
"    if (pos.x < uInputSize.x && pos.y < uInputSize.y)\n"
"    {\n"
"        int C = uInputSize.z;\n"
"        int z = pos.z*4;\n"
"        int vie = min(4, C - z);\n"
"        vec4 v;\n"
"        int idx0 = C*(pos.y*W + pos.x) + pos.z;\n"
"        int vi = 0;\n"
"        for(;vi<vie;++vi){\n"
"          v[vi] = uInBuffer.data[idx0+vi];\n"
"        }\n"
"        imageStore(uImage, pos, v);\n"
"    }\n"
"}\n"
;
const char* normalization_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) readonly uniform PRECISION sampler3D uInput;\n"
"layout(location=2) uniform ivec3 uInputSize;\n"
"layout(binding=3) readonly buffer weight{\n"
"  vec4 data[];\n"
"} uWeight;\n"
"layout(location=4) readonly buffer bias{\n"
"  vec4 data[];\n"
"} uBias;\n"
"layout(location=5) readonly buffer mean{\n"
"  vec4 data[];\n"
"} uMean;\n"
"layout(location=6) readonly buffer variance{\n"
"  vec4 data[];\n"
"} uVariance;\n"
"layout(location=7) uniform float uEps;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"  ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"  if(all(lessThan(pos, uInputSize.xyz)))\n"
"  {\n"
"    vec4 color = texelFetch(uInput, ivec3(pos.x, pos.y, pos.z), 0);\n"
"    vec4 invVar = inversesqrt(uVariance.data[pos.z] + uEps);\n"
"    imageStore(uOutput, pos, (color - uMean.data[pos.z]) * invVar + uBias.data[pos.z]);\n"
"  }\n"
"}\n"
;
const char* tex_to_nc4hw4_buf_glsl = 
"layout(FORMAT, binding=0) readonly uniform PRECISION image3D uImage;\n"
"layout(std430, binding=1) writeonly buffer destBuffer{\n"
"    vec4 data[];\n"
"} uOutBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color = imageLoad(uImage, pos);\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+pos.z*uWidth*uHeight] = color;\n"
"    }\n"
"}\n"
;
const char* tex_to_nchw_buf_glsl = 
"layout(FORMAT, binding=0) readonly uniform PRECISION image3D uImage;\n"
"layout(binding=1) writeonly buffer destBuffer{\n"
"    float data[];\n"
"} uOutBuffer;\n"
"layout(location = 2) uniform int uWidth;\n"
"layout(location = 3) uniform int uHeight;\n"
"layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    if (pos.x < uWidth && pos.y < uHeight)\n"
"    {\n"
"        vec4 color = imageLoad(uImage, pos);\n"
"        int z = pos.z*4;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+0)*uWidth*uHeight] = color.r;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+1)*uWidth*uHeight] = color.g;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+2)*uWidth*uHeight] = color.b;\n"
"        uOutBuffer.data[uWidth*pos.y+pos.x+(z+3)*uWidth*uHeight] = color.a;\n"
"    }\n"
"}\n"
;
const char* threshold_glsl = 
"layout(FORMAT, binding=0, location=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(FORMAT, binding=1, location=1) readonly uniform PRECISION sampler3D uInput;\n"
"layout(location=2) uniform ivec4 uImgSize;\n"
"layout(location=3) uniform float uThreshold;\n"
"layout(location=4) uniform float uValue;\n"
"layout (local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"    ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"    ivec3 imgSize = uImgSize.xyz;\n"
"    if(pos.x < imgSize.x && pos.y < imgSize.y && pos.z < imgSize.z)\n"
"    {\n"
"      vec4 dataIn = texelFetch(uInput, pos, 0);\n"
"      bvec4 lessThreshold = bvec4(lessThan(dataIn, vec4(uThreshold)));\n"
"      imageStore(uOutput, pos, mix(dataIn, vec4(uValue), lessThreshold));\n"
"    }\n"
"}\n"
;
const char* upsampleNearest2d_glsl = 
"layout(std430) buffer;\n"
"layout(FORMAT, binding=0) writeonly uniform PRECISION image3D uOutput;\n"
"layout(location=1) uniform PRECISION sampler3D uInput;\n"
"layout(location=2) uniform ivec3 uInputSize;\n"
"layout(location=3) uniform ivec3 uOutputSize;\n"
"layout(location=4) uniform float uScaleX;\n"
"layout(location=5) uniform float uScaleY;\n"
"layout(local_size_x = WORKGROUP_X, local_size_y = WORKGROUP_Y, local_size_z = WORKGROUP_Z) in;\n"
"void main()\n"
"{\n"
"  ivec3 pos = ivec3(gl_GlobalInvocationID);\n"
"  if(pos.x < uOutputSize.x && pos.y < uOutputSize.y)\n"
"  {\n"
"    float srcX = float(pos.x) * uScaleX;\n"
"    int x1 = int(floor(srcX));\n"
"    int x11 = clamp(x1, 0, uInputSize.x - 1);\n"
"    float srcY = float(pos.y) * uScaleY;\n"
"    int y1 = int(floor(srcY));\n"
"    int y11 = clamp(y1, 0, uInputSize.y - 1);\n"
"    vec4 outValue = texelFetch(uInput, ivec3(x11, y11, pos.z), 0);\n"
"    imageStore(uOutput, pos, outValue);\n"
"  }\n"
"}\n"
;

} } } } //namespace at::native::vulkan::gl
